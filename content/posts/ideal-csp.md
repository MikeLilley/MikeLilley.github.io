---
author: "Michael Lilley"
title: "Ideal Membership and Constraint Satisfaction Problems"
date: "2023-05-28"
description: "We will be describing the application of the ideal membership problem (IMP) and Gröbner bases to the problem of deciding constraint satisfaction problems (CSPs). We will begin with an exposition of the IMP in one variable, then demonstrate how extending our methods to arbitrarily finite variables naturally leads to the construction of Gröbner bases. Following this, we will introduce CSPs, show how the IMP can be used to solve the graph coloring problem, then construct a general framework for translating CSPs into IMPs, following which we will compute Gröbner bases to determine ideal membership."
summary: "We describe the application of the ideal membership problem (IMP) and Gröbner bases to the problem of deciding constraint satisfaction problems (CSPs)."
tags: ["algebraic-geometry", "constraint-satisfaction", "gröbner-bases"]
cover:
    image: ideal_csp_cover.png # image path/url
    hidden: true
---

---

## Introduction

<p>Much of modern algebraic geometry is dedicated to the classification of objects with respect to certain criterion. For instance, we may want to determine if a set of polynomial equations is consistent, i.e. if their common zero set is nonempty. The ideal membership problem is one such problem of classification, which states the following: </p>

><p>Given some polynomial \(f \) and an ideal \(I \in \mathbb{K}[x_1, \cdots, x_n],\) is \(f \in I \)?</p>

<p>Like many things in mathematics, while capable of being stated simply, this in general is anything but an easy problem. Despite this, its immense importance and widespread applicability to problems inside and outside of algebraic geometry has encouraged research into finding solutions. The goal of the following section is to provide motivation and make the reader knowledgeable of computational solutions for the ideal membership problem. We will begin by exploring polynomials of one variable, then move onto the multivariate case.</p>

---

## Polynomials of One Variable
<p>Let \(\mathbb{K} \) be an arbitrary field and let \(f \in \mathbb{K}[x] \) be the polynomial \(f = \sum_{i=0}^n c_ix^i \) where \(c_i \in \mathbb{K} \) and \(c_n \neq 0.\) As a reminder, a <i>polynomial ideal</i> is a subset \(I \subseteq \mathbb{K}[x]\) such that elements in \(I\) are closed under multiplication with elements from the polynomial ring \(\mathbb{K}[x]\) and under addition from elements also in \(I.\) That is to say, a polynomial ideal is just an ideal with its elements coming from \(\mathbb{K}[x].\)</p>

<p>As stated in the following proposition, we can draw a parallel between vector spaces and ideals in the sense that an ideal can be thought of as the set of all linear combinations between products in our ring \(\mathbb{K}[x]\) and some basis set \(B \subseteq I .\) In the case of one variable, this basis set is a singleton set.</p>

><p><b>Proposition 2.1:</b> If \(\mathbb{K}\) is a field, then every ideal \(I\) of \(\mathbb{K}[x]\) can be expressed as \(\langle g \rangle = \sum_i f_i g\) for all \(f_i \in \mathbb{K}[x]\) and some \(g \in I.\)</p>

<p>The proof for this requires Euclid's Division Lemma as adapted to polynomials, which we will state without proof as follows:</p>

><p><b>Lemma 2.2:</b> Let \(\mathbb{K}\) be a field and let \(g \in \mathbb{K}[x]\) be a nonzero polynomial. Then, every \(f \in \mathbb{K}[x]\) can be written as \(f = qg + r,\) where \(q,r \in \mathbb{K}[x]\) are unique and either \(r = 0\) or \(deg(r) < deg(g).\) Furthermore, we may find \(q\) and \(r\) by means of an algorithm.</p>

<p>Now, we may prove <i>Proposition 2.1</i>.</p>

><p> <b>Proof.</b> Let \(I \subseteq \mathbb{K}[x]\) be an ideal. If we consider the trivial case of \(I = \lbrace 0 \rbrace,\) we know that this ideal is generated by \(\langle 0 \rangle.\) For the non-trivial case, let \(g\) be a nonzero polynomial of minimum of degree contained in \(I.\) Our claim is that \(\langle g \rangle = I.\) We will proceed to prove this by mutual set inclusion. \(\langle g \rangle \subseteq I\) is trivial as \(I\) contains all polynomials of the form \(\langle g \rangle = \sum_i f_i g\) since \(g \in I.\) As such, we will prove \(I \subseteq \langle g \rangle.\)
>
> <p> Consider an arbitrary polynomial \(f \in I.\) By Lemma 2.2, we have that \(f = qg + r.\) Since \(I\) is an ideal, we know that \(qg \in I,\) which implies that \(r = f - qg \in I,\) since ideals are closed under addition. Our division lemma states that either \(r = 0\) or \(deg(r) < deg(g).\) If \(r \neq 0,\) then a contradiction is produced, as this implies that all polynomials in \(I\) are of a larger degree than \(r,\) thus \(r \not \in I.\) As a result, \(r = 0.\) This means that \(f = qg,\) therefore \(f \in \langle g \rangle.\) <span style="float:right;">&#9724;</span></p>

<p>This characterization is useful since it allows us to talk about whether a polynomial is an element of some ideal if it can be described as a linear combination of \(g\) with elements of \(\mathbb{K}[x].\) In general, we call \(g\) a generating polynomial or <i>generator</i>. However, we have not yet stated how we can find such a generator. Recall that if \(f\) can be written as a linear combination of \(g,\) then \(f\) is a multiple of \(g:\)</p>

<div data-simplebar>
$$f = q_1 g + q_2 g + \cdots + q_k g = g(q_1 + q_2 + \cdots + q_k) $$
</div>

<p>Thus, we know that \(g\) should always divide \(f.\) As it turns out, the greatest common divisor of the polynomials \(f_1, \cdots, f_s\) will be the generator of \(\langle f_1, \cdots, f_s \rangle.\) We assume the reader is familiar with polynomial division, so we do not spend time on introducing things such as the existence and uniqueness property of the greatest common divisor or the Euclidean Algorithm.</p>

><div data-simplebar>
><p><b>Theorem 2.3:</b> Let \(f_1, \cdots, f_s \in \mathbb{K}[x].\) Then, \(\gcd(f_1, \cdots, f_s)\) is a generator for the ideal \(\langle f_1, \cdots, f_s \rangle.\)</p>
>
><p><b>Proof:</b> Our goal is to show that the generator \(d\) for the ideal \(\langle f_1, \cdots, f_s \rangle\) is equivalent to the greatest common divisor \(\gcd(f_1, \cdots, f_s)\) by proving that it satisfies the following two properties: </p>
><ul>
><li><p>\(d\) divides \(f_1, \cdots, f_s.\)</p></li>
><li><p>If \(p\) is another polynomial which divides \(f_1, \cdots, f_s,\) then \(p\) divides \(d.\)</p></li>
></ul>
><p>By doing this, we demonstrate that it may be computed by the Euclidean algorithm. </p>
></p>Consider the ideal \(\langle f_1, \cdots, f_s \rangle.\) By Proposition 2.1, we know that \(\exists g \in \langle f_1, \cdots, f_s \rangle\) such that \(g\) is a generator for this ideal. (1) is satisfied easily, since  we may write each \(f_i\) as a multiple of \(g\) with an element of \(\mathbb{K}[x]\) as we did above. </p>
><p>To proceed with (2), suppose that there exists a polynomial \(p \in \mathbb{K}[x]\) that divides each \(f_i.\) This means that each \(f_i = q_i p\) for some \(q_i \in \mathbb{K}[x].\) Since \(g \in \langle f_1, \cdots, f_s \rangle,\) we know that there exists some \(k_1, \cdots k_s\) such that \(k_1 f_1 + \cdots + k_s f_s = g.\) If we substitute, we have the following:</p>
><p>$$g = k_1 f_1 + \cdots + k_s f_s = k_1 (q_1p) + \cdots + k_s (q_sp) = (q_1 + \cdots + q_s)p $$</p>
><p>This shows that \(p\) divides \(g.\) Hence, \(g = \gcd(f_1, \cdots, f_s).\) <span style="float:right;">&#9724;</span></p>
></div>

<p>We utilize the fact that \(\gcd(f_1, \cdots, f_s) = \gcd(f_1, \gcd(f_2, \cdots, f_s))\) in order to construct our generator explicitly, so we can find the greatest common divisor of many polynomials by recursively computing it for two polynomials in the ideal. As a demonstration of how this works, consider the following example:</p>

><div data-simplebar>
><p><b>Example 2.4:</b> Suppose we want to find the generator of the ideal given by:
>$$I = \langle x^4 - 1, x^6 - 1, x^3 - x^2 + x - 1 \rangle $$
><p>If we order by degree and use Euclidean division, we have the following:</p>
><p>$$\gcd(x^6 - 1, x^4 - 1) = \gcd(x^4 - 1, x^2 - 1) = \gcd(x^2 - 1, 0) = x^2 - 1  $$</p>
><p>$$\gcd(x^2 - 1, x^3 - x^2 + x - 1) = x - 1 $$</p>
><p>Therefore, \(g = x - 1\) and \(\langle x^4 - 1, x^6 - 1, x^3 - x^2 + x - 1 \rangle = \langle x - 1 \rangle.\)</p>
></div>

<p>We can now apply our construction to our original problem, that of ideal membership. Consider some ideal \(I = \langle f_1, \cdots, f_s \rangle.\) By <i>Proposition 2.1</i>, \(\langle f_1, \cdots, f_s \rangle = \langle g \rangle\) for some \(g \in I,\) and we can find exactly \(g\) is by means of the Euclidean algorithm. By Lemma 2.2, we know that \(f = qg+r.\) An observation we should make is that \(f \in I\) if and only if \(r = 0,\) since we assume that \(deg(r) < deg(g),\) so a representation of \(f\) which requires a polynomial of lower degree would not be in the ideal, as \(r\) cannot be written as a linear combination of \(g.\) This gives us a test to determine if a polynomial is contained within an ideal.</p>


><p><b>Corollary 2.5:</b> Given some polynomial \(f\) and an ideal \(I,\) \(f\in I\) if and only if the generator of \(I\) divides \(f.\)</p>
><p><b>Proof:</b> We know from <i>Theorem 2.3</i> that a generator \(g\) of the ideal \(I = \langle f_1 \cdots, f_n \rangle\) is \(\gcd(f_1 \cdots, f_n).\) In addition, we know that if \(f \in I,\) then any generator \(g\) of \(I\) should divide \(f.\) Chaining these facts together proves our corollary.</p>

<p>We illustrate the use of this theorem with an example.</p>


><p><b>Example 2.6:</b> Consider our ideal in <i>Example 1.4.</i></p>
><ul>
><li><p>\(x^7 + 1 \not \in I,\) as performing polynomial long division with \(x - 1\) gives us a remainder of \(2/(x-1).\)</p></li>
><li><p>\(x^{10} - x^6 - x^4 + 1 \in I,\) since we have no remainder following polynomial long division.</p></li>
></ul>

><p><b>Remark 2.7:</b> This applies to any field, even those with nonzero characteristic.</p>

---

## Polynomials of Many Variables
<p>To recap, we have explored the use of the Euclidean algorithm to retrieve a generator for an ideal \(I \in \mathbb{K}[x],\) and used it to determine if a polynomial is an element of \(I.\) In this section, our goal is to generalize this process to an arbitrarily finite amount of variables. This comes with several challenges that we do not face within the context of one variable, and we'll find that additional algebraic machinery is needed in order to do so without pitfalls. We'll begin this section by attempting to recreate the Euclidean division algorithm for polynomials of multiple variables.</p>

><p><b>Proposition 3.1:</b> Consider taking polynomials \(f_1,f_2 \in \mathbb{K}[x_1,\cdots, x_n]\) and dividing \(f_1\) by \(f_2.\) We claim that there exists an algorithm to do so.</p>

<p>Before we explore this proposition, we must introduce some terminology which will be important going forward:</p>

><p><b>Definition 3.2:</b>
><ul>
><li>The <i>multidegree</i> of a polynomial \(f\) is given as: </p></li>
> $$\mbox{multideg}(f) = \max(\alpha \in \mathbb{N}^n \mid a_\alpha \neq 0) $$
><li>The <i>leading coefficient</i> of a polynomial \(f\) is given as:</p></li>
> $$\mbox{LC}(f) = a_{\mbox{multideg}(f)} \in \mathbb{K}$$
><li>The <i>leading monomial</i> of a polynomial \(f\) is given as:</p></li>
> $$\mbox{LM}(f) = x^{\mbox{multideg}(f)}$$
><li>The <i>leading term</i> of a polynomial \(f\) is given as:</p></li>
> $$\mbox{LT}(f) = \mbox{LM}(f) \cdot \mbox{LC}(f)$$
></ul>

><p><b>Example 3.3:</b> Consider the polynomial \(f = 5xy^6 + 2z:\)</p>
><ul>
><li><p>\(\mbox{multideg}(f) = (1,6,0) \)</p></li>
><li><p>\(\mbox{LC(f)} = 5 \)</p></li>
><li><p>\(\mbox{LM(f)} = xy^6 \)</p></li>
><li><p>\(\mbox{LT(f)} = 5xy^6 \)</p></li>
></ul>

<p>An important point to notice is that tie-breaking conditions for these functions are not yet well-defined. If instead \(f = 5xy^6 + 2z^7,\) does \(\mbox{LT(f)}\) give us \(5xy^6\) or \(2z^7\)? In the following few paragraphs, we will be taking a detour to describe objects called <i>orderings</i> which we associate with polynomials in order to break ties.</p>

<p>In the single-variable case, defining the Euclidean algorithm and speaking of things like the leading term is simple, as we just use the standard total order \(<\) on the natural numbers with respect to the powers of our variable. In more than one variable, the use of this ordering breaks down. As such, we need to define a new ordering. This brings us to our first definition:</p>

<p><b>Definition 3.4:</b> A <i>monomial ordering</i> \(>\) on \(\mathbb{K}[x_1, \cdots, x_n]\) is a relation \(>\) on \(\mathbb{Z}^n_{\geq 0}\) satisfying the conditions that \(>\) is a total and well ordering on \(\mathbb{Z}^n_{\geq 0}\) and \(>\) is preserved under addition.</p>

<p>With our \(\mbox{LT}\) function listed above now being well-defined, we proceed with our original goal of constructing a division algorithm for multivariate polynomials for <i>Proposition 3.1</i>. In addition to generalizing the algorithm to polynomials of multiple variables, we will also generalize to support multiple divisors. The reason for this is as follows: even in the single variable case, we may want to divide a polynomial by many divisors in an effort to factor it. Consider the following polynomial:</p>

<div data-simplebar>

$$f(x) = (x-1)(x + 1)^2 = x^3 + x^2 - x + 1\$$

</div>

<p>If we were to divide this polynomial with the divisors \(x + 1\) and \(x - 1,\) we would have to perform the division algorithm twice, which is computationally expensive as opposed to just dealing with multiple divisors in one pass of the algorithm. Doing this in multiple variables might be somewhat unintuitive at first; we will define the algorithm, go through some examples, then describe caveats which arise when compared to the single-variable case.</p>

<center><img style="max-width:600px; width:auto;" src="../post_assets/ideal_csp/algorithm.png" alt="Algorithm"></img></center>

<p>Let's now go through an example to demonstrate this algorithm being applied.</p>

><p><b>Example 3.7:</b> Let \(f = x^2y + xy^2 + y^2\) and let our divisors be \(f_1 = xy - 1\) and \(f_2 = y^2 - 1.\) Since we label \(xy-1\) with \(f_1,\) we will denote that as our first divisor.</p>
>
><center><img style="max-width:600px; width:auto;" src="../post_assets/ideal_csp/division.png" alt="Algorithm"></img></center>

<p>We saw in the single-variable case that the Euclidean algorithm gave us a generator \(g\) for our ideal, and we were able to test if a polynomial \(f\) was a member of an ideal or not by dividing \(f\) by \(g\) and seeing if \(f/g\) had a remainder. Unfortunately, this test is not as straightforward with many variables. We note that if after following division, we find that \(f = q_1 g_1 + \cdots + q_s g_s,\) then obviously \(f \in \langle f_1, \cdots, f_s \rangle.\) However, as we’ll see next, this is not a requirement. Consider computing division as we do above with the divisors in a different order.</p>

><p><b>Example 3.8:</b> Let \(f = xy^2 -x\) and let our divisors be \(f_1 = xy - 1\) and \(f_2 = y^2 - 1.\) If we divide by \(f_1\) first, we get \(xy^2 - x = y(xy-1) - x + y.\) However, if we divide by \(f_2\) first, we have \(xy^2 - x = x(y^2 - 1).\)</p>

<p>Hence, we see that the test that we constructed in <i>Corollary 2.5</i> does not carry over as readily to multivariate polynomials as well as we would hope. With these issues arising from our attempt to translate the polynomial division algorithm into multiple variables, one might expect we need a different kind of test to determine ideal membership in \(\mathbb{K}[x_1,\cdots, x_n].\)
As it turns out, this method is completely fine; the issues we see are a result of our choice of divisors \(f_1, \cdots, f_s.\) In this next section, we will explore how translating the defining polynomials \(f_1, \cdots, f_s\) of an ideal into a different set \(g_1, \cdots, g_s\) which has nicer properties but still defines the same ideal will produce desired behavior, where remainders are unique and a polynomial \(f\) is in an ideal if and only if the remainder is zero following polynomial division.</p>

---

## Gröbner Bases

<p>In this section, we will be constructing the bases with desirable properties we described in the end of the last section. We begin with three definitions and a lemma which we state without proof.</p>

><div data-simplebar>
><p><b>Definition 4.1:</b> Let \(I \subseteq \mathbb{K}[x_1,\cdots, x_n]\) be a nontrivial ideal and fix a monomial ordering on \(\mathbb{K}[x_1,\cdots, x_n].\) We define \(\mbox{LT}(I)\) as the set of leading terms of nonzero elements in \(I\) given by:</p>
>
>$$\mbox{LT}(I) = \lbrace cx^a \mid \exists f\in I \setminus \lbrace 0 \rbrace \mbox{ with } \mbox{LT}(f) = cx^a \rbrace.$$
></div>

><p><b>Definition 4.2:</b> Let \(I\) be an ideal generated by a set of monomials in \(\mathbb{K}[x_1, \cdots, x_n].\) Then, we call \(I\) a <i>monomial ideal</i>.</p>

><p><b>Lemma 4.3:</b> Let \(I\) be a monomial ideal. Then, the monomial \(\alpha = x_{1}^{a_1} \cdots x_{n}^{a_n}\) is a member of \(I\) if and only if there exists a monomial \(\beta \in I\) which divides \(\alpha.\)</p>

><p><b>Definition 4.4: </b>We say that \(\langle \mbox{LT}(I) \rangle\) is the ideal generated by elements of \(\mbox{LT}(I).\)</p>

<p>It is important to note that \(\langle \mbox{LT}(I) \rangle\) and the ideal given by the leading terms of its defining polynomials \(\langle \mbox{LT}(f_1), \cdots \mbox{LT}(f_s), \rangle\) are not necessarily the same ideal. In particular, it is often that \(\langle \mbox{LT}(f_1), \cdots \mbox{LT}(f_s) \rangle \subseteq \langle \mbox{LT}(I) \rangle.\) The converse is never the case, as \(\mbox{LT}(f_i) \in \mbox{LT}(I)\) as \(f_i \in I.\) Consider the following example:</p>

><div data-simplebar>
><p><b>Example 4.5:</b> Let \(I = \langle x^3 - 2xy, x^2y-2y^2+x \rangle.\) If we use the \(grlex\) ordering, our leading terms are \(x^3\) and \(x^2y.\) We know that we can create \(x^2\) from the following linear combination of our two functions as follows:</p>
>
>$$x(x^2y-2y^2+x) - y(x^3 - 2xy) = x^2 $$
><p>However, we can’t divide \(x^2\) by \(x^3\) or \(x^2y,\) so we know it does not exist in the ideal \(\langle x^3, x^2y \rangle\) by Lemma 4.3.</p>
></div>

<p>The reader might ask if there is anything special about the bases which have the property where \(\langle LT(f_1), \cdots LT(f_s) \rangle = \langle LT(I) \rangle.\) Indeed, there very much is. Before we discuss these though, we will need to introduce a theorem without proof.</p>

><p><b>Theorem 4.6 (Hilbert’s Basis Theorem):</b> Every ideal \(I \in \mathbb{K}[x_1, \cdots, x_n]\) is Noetherian, or has a finite generating set \(g_1, \cdots, g_t \in I.\)</p>

<p>This is a powerful result, since we know we can represent any ideal completely with a finite amount of space. We now exhibit an important definition which describes a particular type of finite generating set.</p>

><p><b>Definition 4.7:</b> If \(g_1,\cdots,g_t \in I\) and \(\langle LT(I) \rangle = \langle LT(g_1), \cdots, LT(g_t) \rangle,\) then we call \(g_1,\cdots,g_t\) a Gröbner Basis to \(I.\)</p>

><p><b>Remark 4.8:</b> Every ideal \(I\) has a Gröbner Basis.</p>

<p>These bases are incredibly important for a variety of reasons. In our case, they will solve our problem of non-uniqueness in the division algorithm for \(\mathbb{K}[x_1,\cdots, x_n],\) as illustrated by the following proposition and corollary:</p>

><p><b>Proposition 4.9:</b> Let \(I \subseteq \mathbb{K}[x_1,\cdots, x_n]\) be an ideal and let \(G = \lbrace g_1,\cdots, g_t \rbrace\) be a Gröbner Basis for \(I.\) Then, given \(f \in \mathbb{K}[x_1,\cdots, x_n],\) there exists a unique \(r\) with the following two properties:</p>
><ul>
>
><li><p>No term of \(r\) is divisible by any of the terms \(LT(g_1), \cdots, LT(g_t).\)</p></li>
><li><p>There is a \(g \in I\) such that \(f = g + r.\)</p></li>
></ul>
>
><p><b>Proof:</b> Given \(f,\) we know that our division algorithm can produce \(f = \sum_i q_ig_i + r,\) where \(r\) satisfies \((1).\) If we let \(g = \sum_i q_ig_i \in I,\) then \((2)\) is also satisfied. To prove that our \(r\) is unique, suppose that \(f = g+r = g' + r'.\) Since \(r\) satisfies our two conditions, we know that \(r - r' = g - g' \in I.\) </p>
>
><p>This implies that if \(LT(r - r') \in \langle I \rangle = \langle LT(g_1),\cdots,LT(g_t) \rangle,\) then \(LT(r - r')\) is divisible by some \(LT(g_i).\) This is because a monomial \(x_{1}^{a_1} \cdots x_{n}^{a_n}\) exists in a monomial ideal if and only if it is divisible by some monomial in the ideal as described by Lemma 4.3. However, this is impossible, as \(deg(r) &lt; deg(g_i)\) if \(r \neq 0\) which means \(r \neq 0.\) Thus, \(r = 0\) and \(r = r',\) which proves that \(r\) is unique.</p>

<p>Finally, we may construct the following corollary:</p>

><p><b>Corollary 4.10:</b> Let \(I \subseteq \mathbb{K}[x_1,\cdots, x_n]\) be an ideal and let \(G = \lbrace g_1,\cdots, g_t \rbrace\) be a Gröbner Basis for \(I.\) Then, \(f \in I\) if and only if the remainder of \(f\) after division with \(G\) is 0.</p>
>
><p><b>Proof:</b> If \(r = 0,\) then \(f = \sum_i q_ig_i,\) which implies that \(f \in I.\) For the converse, if \(f \in I,\) then \(f = f + 0\) satisfies the two conditions above, which implies that 0 is the remainder of \(f\) after dividing by the elements in our Gröbner Basis \(G.\)</p>

<p>At this point, one might wonder how we can generate a Gröbner Basis explicitly. There are many algorithms to do this, and I ask the reader to refer to [1] to see the ones typically used in modern computer algebra systems such as the F5 Signature algorithm, or for Buchberger’s classic algorithm.</p>

<p>With <i>Corollary 4.10</i>, we have solved our dilemma regarding non-unique remainders when performing polynomial division in multiple variables, and subsequently determining ideal membership in \(\mathbb{K}[x_1, \cdots, x_n].\) In the next section, we will show how we can use the ideal membership test to solve constraint satisfaction problems.</p>

---

## Constraint Satisfaction Problems

<p>Up to this point, we have spent time developing a theory of Gröbner Bases in an effort to solve the Ideal Membership Problem in many variables. While a very rich theory in of itself, we have progressed enough in our algebraic geometry prerequisites to now turn our attention to defining CSPs and showing how it can be determined if a CSP is satisfiable using the tools we now have.</p>

<p>On an intuitive level, a <i>constraint satisfaction problem</i> is a problem where one must choose a solution from a set of possible solutions which adheres to a given set of constraints. These may be hard constraints (a necessary set of conditions) or constraints of preference (a set of conditions which are nice to have but not required). For the sake of simplicity, we will only be considering hard constraints and finite amounts of variables. Common examples of CSPs include the integer programming problem or the graph coloring problem, the latter of which we will be using as an example.</p>

<p>In this section, our goal is to develop a method to translate a CSP into a corresponding ideal membership problem.</p>

><p><b>Definition 5.1: </b> A <i>Constraint Satisfaction Problem</i> is a triple \((X, D, C)\) where \(X\) is an \(n\)-tuple \((x_1, \cdots, x_n)\) of variables, \(D\) is an indexed collection of \(n\) sets where each set \(D_i\) is the domain of the \(i^{th}\) variable in \(X,\) and \(C\) is a set of pairs \((t_j, C_j),\) where \(t_j\) is a set of variables \(t_j \subseteq X\) and \(C_j\) is a relation (a subset of the Cartesian product) on the domains of the variables in \(t_j.\) Our set of possible solutions \(P\) is defined as the \(n\)-ary Cartesian product amongst the domains of all variables in \(X.\) Our set of solutions \(S \subseteq P\) is the set of \(n\)-tuples which satisfies every constraint in \(C.\) </p>

<p>If \(S = \varnothing,\) we say that \((X, D, C)\) is unsatisfiable. To be more explicit about the constraints, we say that: </p>

<p>$$ C_j \subseteq \bigtimes_{x \in {t_j}} D_x $$</p>

<p>as the \(k\)-ary Cartesian product amongst all \(k\) variables in \(t_j\) represents all possible configurations between values they could take on from their domains, and a constraint limits the values we can choose to a subset of this Cartesian product. To illustrate, consider the following toy example:</p>

><p><b>Example 5.2:</b> Let \(X = \lbrace x, y \rbrace,\) \(D = \lbrace \mathbb{Z}, \mathbb{Z} \rbrace\) and let our only constraint be that the sum of \(x\) and \(y\) be positive. Thus, our constraint is:</p>
>
>$$C_j = \lbrace (x,y) \in \mathbb{Z}^2 \mid x + y > 0 \rbrace \subseteq \mathbb{Z} \times \mathbb{Z}$$

<p>Next, we will describe graph coloring as a constraint satisfaction problem.</p>

><p><b>Definition 5.3:</b> A \(G = (V,E)\) is a collection of two sets; a set of vertices \(V,\) and a set of edges \(E,\) which consists of ordered pairs \((x_i,y_i)\) where \(x_i,y_i \in V.\)</p>

><p><b>Definition 5.4:</b> We may state the  as follows: A graph \(G\) is \(k\)-colorable if there exists a set of distinct colors \(A\) such that \(|A| = k\) and there exists a function \(f\) to assign a color to each vertex \(v \in V \in G\) such that no two vertices connected by an edge \(e \in E \in G\) have the same color.</p>

<p>Finding efficient ways to solve the graph coloring problem is significant because many different problems can be reformulated as a graph coloring problem. This includes various scheduling problems, register allocation, and pattern matching.</p>

<p>We may write the graph coloring problem as a CSP as follows: Let \((X, D, C)\) be our graph coloring problem in CSP formulation and let \(A\) be our set of colors. We set \(X = V,\) \(D = \lbrace A_1, \cdots, A_n \rbrace,\) and \(C = \lbrace x_i \neq x_j, \forall v_i,v_j \in e \in E \in G \rbrace.\)</p>

<p>Our set of possible solutions is given by: </p>

$$C_j = \bigtimes_{1 \leq i \leq n} D_x$$

<p>As this represents all possible color configurations between \(n\) variables. Our goal is to find our solution set \(S \subseteq P.\)</p>

<p>We can attack this problem using ideal membership, as shown in [9]. To do this, we will work in the ring \(\mathbb{C}[x_1, \cdots, x_n],\) where each of our \(k\) colors are assigned to the \(k\) roots of unity. We will now define the following polynomial which gives us information about the graph:</p>

><p><b>Definition 5.5:</b> The \(f_G \in \mathbb{C}[x_1, \cdots, x_n]\) associated with the graph \(G\) is given by:</p>
>
>$$f_G = \prod_{v_i, v_j \in e} (v_i - v_j)$$

<p>Notice that if we assign two vertices \(v_i\) and \(v_j\) connected by an edge the same color (root of unity), then \(f_G\) vanishes. We now have the following theorem which relates the graph polynomial to the ideal membership problem. To prove this, we need to invoke a famous theorem in algebraic geometry, Hilbert’s Nullstellensatz, or translated, Hilbert’s Theorem of Zeroes. </p>

<p>This is actually one of three forms of the Nullstellensatz; they are each given the adjectives <i>weak</i>, <i>standard</i> and <i>strong</i>, since you need the each prior form to prove the next. Due to the amount of labor involved in proving any of the Nullstellensatz theorems, we will state the standard version without proof.</p>

><p><b>Theorem 5.6 (Hilbert's Nullstellensatz):</b> Let \(\mathbb{K}\) be an algebraically closed field. If \(f, f_1, \cdots f_s \in \mathbb{K}[x_1,\cdots,x_n],\) then \(f \in \mathbb{I}(\mathbb{V}(f_1, \cdots, f_s))\) if and only if: </p>
>$$ f^m \in \langle f_1, \cdots, f_s \rangle $$
><p>for some \(m \in \mathbb{N}.\)</p>

<p>We may now state our theorem.</p>

><p><b>Theorem 5.7:</b> Let \(k \in \mathbb{N}\) and let the graph \(G\) have \(n\) nodes. In addition, let \(I = \langle v_1^k - 1, \cdots, v_n^k - 1 \rangle.\) The graph \(G\) is \(k\)-colorable if and only if \(f_G \not \in I.\)</p>
>
><p><b>Proof.</b> \((\implies):\) If \(G\) is \(k\)-colorable and let \(G\) have \(n\) nodes. We may assign a color to each vertex such that no vertex sharing an edge has the same color. Denote each assigned color as \(a_1, \cdots, a_n.\) Since our graph polynomial only vanishes when two adjacent vertices are the same color, we know that \(f_G(a_1, \cdots, a_n) \neq 0.\) Since we assigned our colors to the \(k\) roots of unity, we know that \((a_1, \cdots, a_n) \in \mathbb{V}(I).\) Since any polynomial in \(I\) must vanish at points within \(\mathbb{V}(I),\) we know that \(f_G \not \in I.\) </p>
>
><p>\((\impliedby):\) Let \(v_i^k - 1 = f_i\) and suppose \(G\) is not \(k\)-colorable. Then, all possible assignments of colors will make \(f_G\) vanish, which means that \(f_G\) vanishes on all points in the variety \(\mathbb{V}(I).\) This means that \(f_G \in \mathbb{I}(\mathbb{V}(f_1, \cdots, f_n)),\) which by the Nullstellensatz implies that \(f^m \in I.\) \(I\) is a radical ideal, which means that \(f \in I.\) <span style="float:right;">&#9724;</span></p>

<p>We can now illustrate the use of this theorem with an example.</p>

><p><b>Example 5.9: </b>Consider the complete graph \(G = K_3,\) given by the triangle of three vertices all mutually connected to one another:</p>
>
><center><img src="../post_assets/ideal_csp/k3_graph.png" alt="K3 Graph"></img></center>
>
><p>We may define our graph polynomial as \(f_G = (x - z)(y - z)(x - y).\) If we choose to 3-color this graph, we may define our ideal as \(I_3 = \langle x^3 - 1, y^3 - 1, z^3 - 1 \rangle.\) None of the defining polynomials in \(I\) divide \(f_G\) which implies that \(f_G \not \in I_3\) so we may say that this graph is 3-colorable. If instead we try to 2-color this graph, our ideal is \(I_2 = \langle x^2 - 1, y^2 - 1, z^2 - 1 \rangle.\) \(x^2 - 1\) divides our graph polynomial, so this implies that \(f_G \in I_2,\) and thus cannot be 2-colored.</p>

<p>So, we just showed how the graph coloring problem could be framed as an ideal membership problem in the sense that the answer to if a particular graph \(G\) could be \(k\)-colored was determined based on if its graph polynomial \(f_G\) was a member of a particular ideal. However, we did not describe why we decided to frame the problem this way, or if there’s a more general framework to translate CSPs into IMPs. </p>

<p>As it turns out, there is a method we can use to translate any CSP into an equivalent IMP, as described in [3]. Let our CSP be given as \((X, D, C)\) where \(|X| = n.\) To begin, we assume \(D \subseteq \mathbb{K}^n\) for some field \(\mathbb{K}.\) At first glance, it might seem like we lose some generality here, as there is no requirement in the definition of our CSP that our variables need to take on the same domains, or even be a field for that matter. For instance, \(x_1\) could be integer-valued and \(x_2\) could be real-valued. </p>

<p>There is no such loss here, as we can simply pick a field which is large enough to contain the domains of all of our variables following an injective mapping. In the case above, we might decide to map \(x_1\) to \(\mathbb{R},\) or we might also decide to map \(x_1\) and \(x_2\) to \(\mathbb{C},\) so we can take advantage of nice properties such as algebraic closure. </p>

<p>Our goal in this correspondence is to describe our solution set \(S\) as the vanishing set of some ideal \(I \subseteq \mathbb{K}[x_1,\cdots, x_n].\) In doing so, we map each constraint to a generating set of some ideal. Consider an arbitrary constraint \((t_j, C_j)\) where \(|t_j| = k.\) As described above, \(C_j\) is a subset of the \(k\)-ary Cartesian product and consists of points of the form \((v_1,\cdots,v_k).\) Let \(x_{i_a} \in t_j.\) Consider the ideal of \(\mathbb{K}[x_1,\cdots, x_n]\) for some point \(v \in C_j\) given by \(I_{j_v} = \langle x_{i_1} - v_1, \cdots,x_{i_k} - v_k \rangle\); we know this is maximal and therefore radical since it is an ideal of linear polynomials. Likewise, we know that \(\mathbb{V}(I_{j_v}) \in C_j \subseteq \mathbb{K}^k.\) </p>

<p>As a standard result about varieties, we know that \(\mathbb{V}(I \cap J) = \mathbb{V}(I) \cup \mathbb{V}(J).\) Also, it is a property of radical ideals that \(\mathbb{V}(\mathbb{I}(V)) = V.\) As such, we can say that: 

<div data-simplebar>
$$C_j = \bigcup_{v \in C_j} \mathbb{V}(\langle x_{i_1} - v_1, \cdots,x_{i_k} - v_k \rangle) = \mathbb{V}(\mathbb{I}(C_j)) \quad \mbox{where} \quad \mathbb{I}(C_j) = \bigcap_{v \in C_j} I_{j_v}$$
</div>

<p>We know that \(\mathbb{I}(C_j)\) is zero-dimensional since it is finite and radical since the intersection of radical ideals is radical. </p>

<p>If we wanted to construct a set of points which satisfies all constraints in the CSP, a natural idea is to just simply take the intersection of the vanishing sets of all \(C_j \in C.\) By the above lemma, we know that the intersection of the vanishing sets of many ideals is equivalent to the vanishing set of the sum of all the ideals. </p>

<p>Since \(\mathbb{V}(I) \cap \mathbb{V}(J) = \mathbb{V}(I + J),\) this may be written as:</p>

<div data-simplebar>
$$\bigcap_{C_j \in C} \mathbb{V} \Bigg ( \bigcap_{v \in C_j} I_{j_v} \Bigg ) = \mathbb{V} \Bigg ( \sum_{C_j \in C} \bigcap_{v \in C_j} I_{j_v} \Bigg )$$
</div>

<p>The last thing we need to consider is how to ensure that the vanishing set of our ideal is consistent with the domains of each variable when we operate in a field larger than some domain \(D_i.\) For this, we introduce a notion of a .</p>

<p>Consider the ideal \(\mathbb{I}(C_j)\) given above. We will take the intersection of this ideal with the ideal that has \(|t_j| = k\) generators, and the generator corresponding to a particular variable \(\gamma = x_{i_a} \in t_j\) given by: </p>

$$g_\gamma = \prod_{p \in D_\gamma} (\gamma -  p)$$

<p>Now, if we redefine our ideal as \( C_j’ = C_j \cap \langle g_{\gamma_1}, \cdots, g_{\gamma_k} \rangle ,\) we know that \(\mathbb{I}(C_j)'\) will vanish if and only if each variable takes on a value in their respective domain. We will see the necessity of these domain polynomials in Example 6.2.</p>

<p>Finally, note that while the sum of radical ideals is not necessarily radical, we invoke the following theorem from [2] to show that in our particular case, we know that the ideal given by the sum of our ideals is radical.</p>

<p><b>Theorem 5.10: </b>Let \(m \in \mathbb{N}.\) For each \(i \leq m,\) let \(X_i\) be a non-empty set of variables. Furthermore, let \(X=\bigcup _{i=1}^mX_i,\) let \(R=\mathbb{K}[X],\) let \(I_i\) be a zero-dimensional radical ideal of \(k[X_i]\) and let \(R_i\) be the \(R\)-module of \(I_i\) for \(1 \leq i \leq m.\) Finally, let \(J \subseteq \mathbb{K}[X]\) be the ideal given by \(J = \sum_{i=1}^m R_i.\) Then, \(J\) is either inconsistent or a zero-dimensional radical ideal of \(R.\)</p>

<p>We ask the reader to refer to <i>Proposition 3.22</i> of [2] for the proof of this theorem. If our CSP has a solution, then this means that the sum of our ideals is radical.
To find out if our CSP has a solution, we have to determine if our variety is empty. This is equivalent to determining if \(1 \in I.\) It should be noted that once we compute the Gröbner basis, we no longer actually need to perform polynomial division to determine this. </p>

<p>By <i>Corollary 4.10</i>, we know that if there are no constants in our Gröbner basis, then we obviously can’t have a zero remainder with a dividend of 1. The discussion in prior sections regarding the relation between polynomial division and ideal membership was primarily to motivate the construction of Gröbner bases. Now that we have them, we no longer need the algorithm described in the section <i>Polynomials of Many Variables</i>.</p>

For the examples in the next section, we will use Singular [8] to compute Gröbner bases, which is a specialized computer algebra system for algebraic geometry.</p>

---

## Computational Examples
### The Boolean Satisfiability Problem
<p>Our first problem we will solve will be a simple one, that of Boolean satisfiability. It states the following: <i>Given some Boolean formula \(F,\) is there a configuration of its variables \((x_1, \cdots, x_n)\) such that \(F(x_1, \cdots, x_n) = 1\)</i>? That is, can \(F\) be satisfied?</p>
<p>Consider the formula given by \(F = (A \wedge B) \vee (C \wedge \neg A) \wedge (\neg A \vee \neg B \vee C).\)</p>
<p>This is expressed as a CSP \((X, D, C)\) where \(X = \lbrace A, B, C \rbrace\) and \(D = \lbrace \mathbb{Z}_2, \mathbb{Z}_2, \mathbb{Z}_2 \rbrace.\) To get our constraints, we will transform \(F\) into an equivalent expression that is in <i>Disjunctive Normal Form (DNF)</i>. This form is a series of sub-expressions connected by <i>or</i> operators. That is to say, \( F = \bigvee_{i = 1}^k F_i .\)</p>

<p>Any Boolean expression can be transformed into DNF. The result following transformation is \(F =  (A \wedge B) \vee (\neg A \wedge C).\) So, we know that the our constraints are given as:</p>
<ul>
<li"><p>\(C_1 = (\lbrace A, B \rbrace, \lbrace(0, 0), (1, 1) \rbrace )\)</p></li>
<li"><p>\(C_2 = (\lbrace A, C \rbrace, \lbrace(0, 1), (1, 0) \rbrace )\)</p></li>
</ul>

<p>The difference here from the examples we’ve dealt with in prior sections is that we only need to satisfy one of these constraints, rather than both. For this reason, we could consider our solution set to the union of the vanishing sets of the ideals formed from these constraints. We may write our ideals as follows:</p>

<div data-simplebar>
$$C_1 = \mathbb{V}(\langle A, B \rangle) \cup \mathbb{V}(\langle A - 1, B - 1 \rangle)$$
$$C_2 = \mathbb{V}(\langle A - 1, C \rangle) \cup \mathbb{V}(\langle A, C - 1 \rangle)$$
$$C_1 \cup C_2 = \mathbb{V}(\langle A, B \rangle) \cup \mathbb{V}(\langle A - 1, B - 1 \rangle) \cup \mathbb{V}(\langle A - 1, C \rangle) \cup \mathbb{V}(\langle A, C - 1 \rangle)$$
</div>
<p>To figure out if this is solvable, we have to determine if: </p>


<div data-simplebar style="border:1px solid; border-color: #777777;">
<pre style="margin:20px">
&gt; ring r = (ZZ/2)[A, B, C];
&gt; ideal i1 = A, B;
&gt; ideal i2 = A - 1, B - 1;
&gt; ideal i3 = A, C - 1;
&gt; ideal i4 = A - 1, C;
&gt; ideal i5 = intersect(i1, i2, i3, i4);
&gt; groebner(i5);
_[1]=AB+AC+BC+B
_[2]=A2+A
_[3]=AC2+BC2+AC+BC
_[4]=B2C2+B2C+BC2+BC</pre>
</div>

### The *n*-Queens Problem
<p>This is a classic problem in computer science education, typically introduced in a student’s first algorithms class when teaching the method of backtracking to solve CSPs. It can be stated as follows: Given an \(n\times n\) chessboard, can we place \(n\) queens in such a way that they cannot attack each other? For those who are reading this who do not play chess, a queen can attack another piece if it is directly horizontal, diagonal, or vertical from the location of the queen on the board.</p>
<center><img src="../post_assets/ideal_csp/chess_queens.png" alt="Chess Queens"></img></center>

<p>In order to formulate this into a CSP, we will need to create polynomials which will be zero if and only if two queens are not attacking each other. As we’ll see shortly, this is quite a laborious task, and requires 19 different polynomials for the \(4 \times 4\) case.</p>

<p>To start, we let each square be a separate variable, so in the \(4\times 4\) case, we will have 16 variables. Similar to the prior example, our elements can take on values in the finite field \(\mathbb{Z}_2\); a square will be 0 if no queen is present, and 1 if a queen is present. We will make a polynomial for each row, column, and diagonal. This polynomial should have a value greater than zero if and only if two or more queens exist on a particular attacking line.</p>

<p>In order to construct these polynomials, we will sum the monomials formed from all possible ways of multiplying two variables on an attacking line. For the vertical, horizontal, and main diagonal attacking lines, we will have \({4\choose 2} = 6\) terms. The way we assign variables to our squares will be as follows:</p>

<center><img src="../post_assets/ideal_csp/chess_labeled.png" alt="Chess Labeled"></img></center>

<p>Our polynomials will be as follows:</p>

<div data-simplebar>
\[
\begin{array}{|l|}
\hline
\textbf{Diagonal Down} \\
\hline
a_1a_6 + a_1a_{11} + a_1a_{16} + a_6a_{11} + a_6a_{16} + a_{11}a_{16} \\
a_5a_{10} + a_5a_{15} + a_{10}a_{15} \\
a_3a_8 \\
a_9a_{14} \\
a_2a_7 + a_2a_{12} + a_{7}a_{12} \\
\hline
\textbf{Diagonal Up} \\
\hline
a_4a_7 + a_4a_{10} + a_4a_{13} + a_7a_{10} + a_7a_{13} + a_{10}a_{13} \\
a_3a_{6} + a_3a_{9} + a_{6}a_{9} \\
a_2a_5 \\
a_{12}a_{15} \\
a_8a_{11} + a_8a_{14} + a_{11}a_{14} \\
\hline
\textbf{Vertical} \\
\hline
a_1a_5 + a_1a_{9} + a_1a_{13} + a_5a_{9} + a_5a_{13} + a_{9}a_{13} \\
a_2a_6 + a_2a_{10} + a_2a_{14} + a_6a_{10} + a_6a_{14} + a_{10}a_{14} \\
a_3a_7 + a_3a_{11} + a_3a_{15} + a_7a_{11} + a_7a_{15} + a_{11}a_{15} \\
a_4a_8 + a_4a_{12} + a_4a_{16} + a_8a_{12} + a_8a_{16} + a_{12}a_{16} \\
\hline
\textbf{Horizontal} \\
\hline
a_1a_2 + a_1a_{3} + a_1a_{4} + a_2a_{3} + a_2a_{4} + a_{3}a_{4} \\
a_5a_6 + a_5a_{7} + a_5a_{8} + a_6a_{7} + a_6a_{8} + a_{7}a_{8} \\
a_9a_{10} + a_9a_{11} + a_9a_{12} + a_{10}a_{11} + a_{10}a_{12} + a_{11}a_{12} \\
a_{13}a_{14} + a_{13}a_{15} + a_{13}a_{16} + a_{14}a_{15} + a_{14}a_{16} + a_{15}a_{16} \\
\hline
\end{array}
\]
</div>

<p>In addition to this, we have the constraint that four queens must be on the board. As a result, the last polynomial we’ll include is:</p>

$$ \sum_{i=1}^{16} a_i - 4 = 0 $$

<p>While these polynomials accurately describe the constraints, we are not quite done yet, as we need to construct ideals in the form described in section 5. In total, we are going to have 76 different ideals within a sum. As one can see, even simple CSPs can become quite large rather quickly. We will construct an ideal for each of our terms in our polynomial, and then consider the sum of each ideal, as each of these constraints must be satisfied simultaneously.</p>

<p>In addition, since we are putting a restriction on a particular count with the previous polynomial, we need to operate in a ring with characteristic zero. If we did not, trying to place 16 queens on the board would mean our last polynomial will be: </p>

$$\sum_{i=1}^{16} a_i - 16 = 0 $$

<p>It will give us the same Gröbner basis since \(4 \equiv 16 \mod 2,\) but obviously we cannot place 16 queens on the board without them attacking each other. For this reason, we will need to create additional ideals with generators (domain polynomials), and sum them with our other ideals to ensure that our variables only take on binary values. Each variable \(a_i\) will have a domain polynomial ideal of \(P_i = \langle a_i(a_i - 1) \rangle.\)</p>

<p>Let \(a_{i}a_{j}\) be a particular term in one of our polynomials above. Our vanishing set of each ideal will be of the form:</p>

<div data-simplebar>
$$\mathbb{V}(\langle a_i, a_j \rangle) \cup \mathbb{V}(\langle a_i - 1, a_j \rangle) \cup \mathbb{V}(\langle a_i, a_j - 1 \rangle).$$ 
</div>

<p>As such, our ideal of interest for each term is:</p>
<div data-simplebar>
$$I_{i,j} = \langle a_i, a_j \rangle \cap \langle a_i - 1, a_j \rangle \cap \langle a_i, a_j - 1 \rangle.$$
</div>
<p>If we let \(C_k = I_{i,j} + P_i + P_j\) be a particular constraint, then our solution set to our entire problem is represented by: </p>

<div data-simplebar>
$$\bigcap_{C_k \in C} \mathbb{V} (I_{i,j}) \cap \mathbb{V} (P_i) \cap \mathbb{V} (P_j) = \mathbb{V} \Bigg ( \sum_{C_k \in C} C_k\Bigg ) $$
</div>

<p>Again, we compute the Gröbner basis using Singular, although this time we only show a portion of the code, as the entire program and output is quite long. We operate over the field \(\mathbb{Q}\) for this.</p>

<div data-simplebar style="border:1px solid; border-color: #777777;">
<pre style="margin:20px">
ring r = QQ,(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16), dp;
> ideal d1 = a1*(a1-1);
>   //domain polynomials 2-15 here
> ideal d16 = a16*(a16-1);
> ideal i0 = a1, a6;
> ideal j0 = a1 - 1, a6;
> ideal k0 = a1, a6 - 1;
> ideal m0 = intersect(i0, j0, k0) + d1 + d6;
>   //terms 1-74 here
> ideal i75 = a15, a16;
> ideal j75 = a15 - 1, a16;
> ideal k75 = a15, a16 - 1;
> ideal m75 = intersect(i75, j75, k75) + d15 + d16;
> ideal m76 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 - 4;
> groebner(m1 ... m76);
_[1]=a16^2-a16
_[2]=a15*a16
_[3]=a14*a16
_[4]=a13*a16
_[5]=a12*a16
//basis elements 6-91 here
_[92]=a1*a3
_[93]=a2^2-a2
_[94]=a1*a2
_[95]=a1^2-a1</pre></div>

<center><p>Since there aren't constant basis elements, the 4-queens problem has a solution.</p></center>

### The Vertex Cover Problem

<p>The vertex covering problem is another important problem in computer science, particular when it comes to the notion of simplification and reduction. It may be stated as follows: <i>Given some graph \(G\)</span>, can we pick \(k \in \mathbb{N}\)</span> nodes such that every edge in the graph is incident to at least one of our selected nodes?</i></p>
<center><img src="../post_assets/ideal_csp/graph.png"></img></center>

<p>In the case of this graph, \(S = \lbrace a_2, a_3, a_5, a_7 \rbrace\)</span> would be a vertex cover. To translate this into the language of ideals, we will once more operate in \(\mathbb{Q}.\)</p>

<p>Since any edge is incident to two nodes \(a_i, a_j,\) we will say that to cover an edge, either \(a_i = 1\) or \(a_j = 1\) for each edge. For our graph above, this translates into the polynomial:</p> 

<div data-simplebar>
$$ (a_1 - 1)(a_2 - 1) + (a_1 - 1)(a_3 - 1) + (a_2 - 1)(a_6 - 1) + (a_2 - 1)(a_6 - 1) + $$
$$(a_3 - 1)(a_4 - 1) + (a_3 - 1)(a_5 - 1) + (a_5 - 1)(a_7 - 1) + $$
$$(a_5 - 1)(a_8 - 1) + (a_7 - 1)(a_8 - 1) $$
</div>

<p>Just like before, we can split this into a sum of intersections and compute using Singular:</p>

<div data-simplebar style="border:1px solid; border-color: #777777;">
<pre style="margin:20px">
> ring r = QQ,(a1, a2, a3, a4, a5, a6,a7,a8),dp;
> //Domain Polynomials
> ideal d1 = a1*(a1-1);
> //domain polynomials 2-7 here
> ideal d8 = a8*(a8-1);
> ideal i0 = a1 - 1;
> ideal j0 = a2 - 1;
> ideal k0 = intersect(i0, j0);
> ideal m0 = d1 + d2 + k0;
> //terms 1-7 here
> ideal i8 = a5 - 1;
> ideal j8 = a7 - 1;
> ideal k8 = intersect(i8, j8);
> ideal m8 = d5 + d7 + k8;
> ideal m9 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 - 4;
> groebner(m1 + m2 + m3 + m4 + m5 + m6 + m7 + m8 + m9);
_[1]=a6
_[2]=3*a5+a6+3*a7+3*a8-6
_[3]=3*a4+a6
_[4]=a3-1
_[5]=a2-1
_[6]=a1+a2+a3+a4+a5+a6+a7+a8-4
_[7]=a8^2-a8
_[8]=a7*a8-a7-a8+1
_[9]=a7^2-a7</pre></div>

<p>There are no constants which implies that this CSP is satisfiable. If we instead attempted to cover the graph with two vertices rather than four by changing <code>ideal m9 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 - 4;</code> to the statement <code>ideal m9 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 - 2;</code>, we get a basis of just one element, <code>_[1]=1</code>. This implies that it is impossible to cover our graph with only two vertices, rendering the CSP unsatisfiable.</p>

---

## Computational Complexity
<p>As we compute Gröbner bases, a natural question to ask is how efficient these algorithms are. In addition, the reader might notice that we only discussed how to determine if a particular CSP is solvable or not, and did not go into detail to describe how to find a particular solution. This is because the generation of a solution using algebraic geometry is a much harder problem.</p>
<p>When we were determining if a set of polynomials has a mutual solution, we just have to find if 1 exists its characteristic ideal. When generating a solution, we actually have to solve the system of polynomials which makes up our characteristic ideal. For doing this, I refer the reader to [4] for an in-depth discussion.</p>
<p>With regards to the first question, we begin with an informal discussion about time and space complexity.</p>

<p><b>Definition 7.1:</b> We define a <em>complexity class</em> as a set of decision problems, membership in which is determined by a complexity measure \(C\)</span>.</p>

<p>While we don’t explicitly define what a decision problem is, we refer to the reader’s intuition in that it is any problem which can be posed as a yes-no question based on its inputs. All examples given above are decision problems. </p>

<p>The complexity measure we typically use for determining membership is the existence of an algorithm to solve the problem where its growth of time and space requirements is bounded in some fashion as the problem itself grows. Time requirements are typically regarded as the amount of steps an algorithm has to take in order to solve a problem with respect to a certain operation.
For instance, we may regard the amount of time taken by a sorting algorithm as the amount of element swaps needed before all elements in a data structure are placed in a particular order. Likewise, we may regard the amount of time taken by a searching algorithm to be the amount of elements that need to be checked before we find the element we are looking for or can conclusively determine that the element does not exist.</p>

<p>Analogously, space requirements may be regarded as the amount of data an algorithm has to store with respect to a certain unit in order to solve a problem. It is important to note that the space requirements of an algorithm are always less than or equal to the time requirements of the algorithm. If we can guarantee that a decision problem \(D\) has an algorithm which has time (or space) requirements \(f(n)\) that are eventually bounded by \(g(n),\) we say that \(D\) is in the complexity class defined by \(g(n),\) or \(D \sim \mathcal{O}(g(n)).\)</p>

<p><b>Definition 7.2:</b> Let \(D\)</span> be a decision problem and let \(f(n)\)</span> be the time (or space) requirements to an algorithm which solves \(D\)</span>. We say an algorithm is bounded by \(g(n)\)</span> if and only if there exists an \(M &gt; 0\)</span> and \(n_0 \in \mathbb{N}\)</span> such that \(|f(n)| \leq Mg(n), \ \forall n &gt; n_0\)</span> .</p>

<p>We typically characterize decision problems by their boundedness by certain classes of functions, like polynomials or exponential functions. Below is a table which describes common time complexities (and analogously, space complexities):</p>

<div data-simplebar>
$$
\begin{array}{|c|c|c|}
\hline
  \textbf{Class Name} & \textbf{Bounded By} & \textbf{Example Problem} \\ 
\hline
   \text{CONSTANT} & 1 & \text{Computing} (-1)^n \\
\hline
   \text{DLOGTIME} & \log(n) & \text{Binary Search} \\
\hline
    \text{P} & \text{poly}(n) & \text{Fast Fourier Transform} \\
\hline
    \text{QUASI-P} & 2^{\text{poly}(\log(n))} & \text{Graph Isomorphism} \\
\hline
    \text{EXPTIME} & 2^{\text{poly}(n)} & \text{Evaluating a Chess Position} \\
\hline
    \text{FACTORIAL} & n! & \text{Traveling Salesman with Brute Force} \\
\hline
\end{array}
$$
</div>

<p>Computing Gröbner bases is in the class \(2-EXPTIME\) following the development of the F5 algorithm [2], which means that the algorithm is bounded by \(2^{2^{poly(n)}}.\) This is regarded as quite slow and intractable. However, despite them being theoretically intractable, they are often fast to compute in practice; computing the Gröbner bases in each example above took roughly 0.2 seconds on an Intel i9-12900K.</p>

<p>Another interesting result is that if we restrict our computation to the Boolean field \(\mathbb{F}_2\) we can guarantee that the space requirements exist in \(PSPACE\) [4]. </p>

<p>With all that being said, computing Gröbner bases for determining the satisfiability of a CSP by themselves is only of theoretical, not practical interest at this moment. Currently, there exist CSP solvers utilizing searching algorithms outside of algebraic geometry with fine-tuned heuristics that operate significantly faster than the F5 algorithm. Despite this, it may turn out one day that this construction may one day be the key to proving an otherwise impossible theorem or be used in conjunction with other techniques to create a CSP solver with speeds far exceeding anything available today.</p>

---

## Concluding Remarks and Further Reading

<p>It is my hope that the reader has found this to be an easy-to-read introduction to the connection between Gröbner bases and CSPs. Gröbner bases also appear in many other places within computer science, such as in a proof that network coding can be implemented within flow networks [5], as well as various places within cryptography and coding theory [6]. I encourage the reader to pick up a book such as [7] to learn more about their applications.</p>

<p>A strong recommendation of mine if you want to learn more about the concepts and algorithms we’ve explored is [1]. The first part of this post concerning the introduction of the ideal membership problem and Gröbner bases borrowed heavily from it.</p>

<p>Finally, for an in-depth treatment of the correspondence between ideals and CSPs, consider reading [2] and [3].</p>

---

## References

<p>[1] Cox, D., Little, J., & OShea, D. (2013). Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media.</p>
<p>[2] Van Dongen, M. R. (2002). Constraints, Varieties, and Algorithms (Doctoral dissertation, NUI).</p>
<p>[3] Bulatov, A. A., & Rafiey, A. (2022, June). On the complexity of csp-based ideal membership problems. In Proceedings of the 54th Annual ACM SIGACT Symposium on Theory of Computing (pp. 436-449).</p>
<p>[4] Tran, Q. N. (2008). A p-space algorithm for groebner bases computation in boolean rings. International Journal of Mathematical and Computational Sciences, 2(9), 641-647.</p>
<p>[5] Koetter, R., & Médard, M. (2003). An algebraic approach to network coding. IEEE/ACM transactions on networking, 11(5), 782-795.</p>
<p>[6] Sala, M. (2009). Gröbner bases, coding, and cryptography: a guide to the state-of-art (pp. 1-8). Springer Berlin Heidelberg.</p>
<p>[7] Adams, W. W., & Loustaunau, P. (2022). An introduction to Gröbner bases (Vol. 3). American Mathematical Society.</p>
<p>[8] Greuel, G., Pfister, G., & Schönemann, H. (2001). SINGULAR: a computer algebra system for polynomial computations. ACM Commun. Comput. Algebra, 42, 180-181.</p>
<p>[9] Merhle, D. (2014)., A Variety of Graph Coloring Problems.</p>

---
